<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python传递参数究竟是值传递还是引用传递]]></title>
    <url>%2F2018%2F12%2F08%2Fpython-passParam%2F</url>
    <content type="text"><![CDATA[首先还是应该科普下函数参数传递机制，传值和传引用是什么意思？ 函数参数传递机制问题在本质上是调用函数（过程）和被调用函数（过程）在调用发生时进行通信的方法问题。基本的参数传递机制有两种：值传递和引用传递。 值传递（passl-by-value）过程中，被调函数的形式参数作为被调函数的局部变量处理，即在堆栈中开辟了内存空间以存放由主调函数放进来的实参的值，从而成为了实参的一个副本。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。 引用传递(pass-by-reference)过程中，被调函数的形式参数虽然也作为局部变量在堆栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过堆栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。 那么,python究竟是怎样的呢 123456789101112131415161718192021222324from ctypes import *import os.path import sysdef test(c): print("test before ") print(id(c)) c+=2 print("test after") print(id(c)) return cdef printIt(t): for i in range(len(t)): print(t[i])if __name__=="__main__": a=2 print("main before invoke test") print(id(a)) n=test(a) print("main afterf invoke test") print(a) print(id(a)) 12345main before invoke testtest before test after +main afterf invoke test39601564 从上可以看出，传参数进去时，传得是引用，因为参数地址没变。但是对传入参数赋值后，其地址就发生了变化。基于这个例子画了个图表示 那么python传递参数传得真是引用，然后传参的值在被调函数内被修改也不影响主调函数的实参变量的值？有传入对象可变与不可变的说法，对于可变对象，在被调函数内修改传参会影响主调函数的实参变量，对于不可变对象修改传参则不会改变主调函数实参的值，因为修改不可变对象实际上是另开辟内存重新赋值并让传参变量指向该内存。看下面例子 123456789101112131415161718192021222324from ctypes import *import os.path import sysdef test(list2): print("test before ") print(id(list2)) list2[1]=30 print("test after +") print(id(list2)) return list2def printIt(t): for i in range(len(t)): print(t[i])if __name__=="__main__": list1=["loleina",25,'female'] print("main before invoke test") print(id(list1)) list3=test(list1) print("main afterf invoke test") print(list1) print(id(list1)) 123456789main before invoke test4485568072test before 4485568072test after +4485568072main afterf invoke test[&apos;loleina&apos;, 30, &apos;female&apos;]4485568072 结论：python不允许程序员选择采用传值还是传引用。Python参数传递采用的肯定是“传对象引用”的方式。这种方式相当于传值和传引用的一种综合。如果函数收到的是一个可变对象（比如字典或者列表）的引用，就能修改对象的原始值－－相当于通过“传引用”来传递对象。如果函数收到的是一个不可变对象（比如数字、字符或者元组）的引用，就不能直接修改原始对象－－相当于通过“传值’来传递对象。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python在命令行下查看模块，函数的用法]]></title>
    <url>%2F2018%2F11%2F29%2Fpython-help%2F</url>
    <content type="text"><![CDATA[python的一个优势是有着大量自带和在线的模块(module)资源，可以提供丰富的功能，在使用这些模块的时候，如果每次都去网站找在线文档会过于耗费时间，结果也不一定准确。因此这里介绍下python自带的查看帮助功能，可以在编程时不中断地迅速找到所需模块和函数的使用方法。 通用帮助函数help()在python命令行中键入help(),可以看到：1234567891011121314151617&gt;&gt;&gt; help()Welcome to Python 3.5&apos;s help utility!If this is your first time using Python, you should definitely check outthe tutorial on the Internet at http://docs.python.org/3.5/tutorial/.Enter the name of any module, keyword, or topic to get help on writingPython programs and using Python modules. To quit this help utility andreturn to the interpreter, just type &quot;quit&quot;.To get a list of available modules, keywords, symbols, or topics, type&quot;modules&quot;, &quot;keywords&quot;, &quot;symbols&quot;, or &quot;topics&quot;. Each module also comeswith a one-line summary of what it does; to list the modules whose nameor summary contain a given string such as &quot;spam&quot;, type &quot;modules spam&quot;.help&gt; 进入help帮助文档界面，根据屏幕提示可以继续键入相应关键词进行查询，继续键入modules可以列出当前所有安装的模块：12345678910help&gt; modulesPlease wait a moment while I gather a list of all available modules...AutoComplete _pyio filecmp pyscreezeAutoCompleteWindow _random fileinput pytweening...... Enter any module name to get more help. Or, type &quot;modules spam&quot; to searchfor modules whose name or summary contain the string &quot;spam&quot;. 可以继续键入相应的模块名称得到该模块的帮助信息。这是python的通用的查询帮助，可以查到几乎所有的帮助文档，但我们很多时候不需要这样层级式地向下查询，接下来会介绍如何直接查询特定的模块和函数帮助信息。 模块帮助查询查看.py结尾的普通模块help(module_name)例如要查询math模块的使用方法，可以如下操作：12345678910111213141516171819&gt;&gt;&gt; import math&gt;&gt;&gt; help(math)Help on built-in module math:NAME mathDESCRIPTION This module is always available. It provides access to the mathematical functions defined by the C standard.FUNCTIONS acos(...) acos(x) Return the arc cosine (measured in radians) of x....&gt;&gt;&gt; 使用help(module_name)时首先需要import该模块，有些教程中不进行导入而在模块名中加入引号help(‘module_name’)，这种方法可能会带来问题，大家可以用math模块测试，建议使用先导入再使用help()函数查询。 查看内建模块sys.bultin_modulenames1234&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.builtin_module_names(&apos;_ast&apos;, &apos;_bisect&apos;, &apos;_codecs&apos;, &apos;_codecs_cn&apos;, &apos;_codecs_hk&apos;, ... &apos;zlib&apos;)&gt;&gt;&gt; 需要导入sys模块。这里列举的一般是自带的使用C/C++编译链接的模块 查询函数信息查看模块下所有函数dir(module_name)如我们需要列举出math模块下所有的函数名称123&gt;&gt;&gt; dir(math)[&apos;__doc__&apos;, &apos;__loader__&apos;, &apos;__name__&apos;,...]&gt;&gt;&gt; 同样需要首先导入该模块 查看模块下特定函数信息help(module_name.func_name)如查看math下的sin()函数 123456789&gt;&gt;&gt; help(math.sin)Help on built-in function sin in module math:sin(...) sin(x) Return the sine of x (measured in radians).&gt;&gt;&gt; 查看函数信息的另一种方法print(func_name.doc)如查看内建函数print用法。既可以用来查看内建函数，也可以查看模块函数信息。 123456&gt;&gt;&gt; print(print.__doc__)print(value, ..., sep=&apos; &apos;, end=&apos;\n&apos;, file=sys.stdout, flush=False)Prints the values to a stream, or to sys.stdout by default....&gt;&gt;&gt; doc前后是两个短下划线，在python中会合并为长下划线python中的help()类似unix中的man指令，熟悉后会对我们的编程带来很大帮助]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的lambda表达式]]></title>
    <url>%2F2018%2F11%2F29%2Fpython-lambda%2F</url>
    <content type="text"><![CDATA[这里，我们通过阅读各方资料，总结了关于Python中的lambda的“一个语法，三个特性，四个用法”。 一个语法在Python中，lambda的语法是唯一的。其形式如下： lambda argument_list: expression 其中，lambda是Python预留的关键字，argument_list和expression由用户自定义。具体介绍如下。这里的argument_list是参数列表。它的结构与Python中函数(function)的参数列表是一样的。具体来说，argument_list可以有非常多的形式。例如： a, b a=1, b=2 *args **kwargs a, b=1, *args 空 …… 这里的expression是一个关于参数的表达式。表达式中出现的参数需要在argument_list中有定义，并且表达式只能是单行的。以下都是合法的表达式： 1 None a + b sum(a) 1 if a &gt;10 else 0 …… 这里的lambda argument_list: expression表示的是一个函数。这个函数叫做lambda函数。 三个特性lambda函数有如下特性： lambda函数是匿名的：所谓匿名函数，通俗地说就是没有名字的函数。lambda函数没有名字。 lambda函数有输入和输出：输入是传入到参数列表argument_list的值，输出是根据表达式expression计算得到的值。 lambda函数一般功能简单：单行expression决定了lambda函数不可能完成复杂的逻辑，只能完成非常简单的功能。由于其实现的功能一目了然，甚至不需要专门的名字来说明。 下面是一些lambda函数示例：1234567lambda x, y: x*y；函数输入是x和y，输出是它们的积x*ylambda:None；函数没有输入参数，输出是Nonelambda *args: sum(args); 输入是任意个数的参数，输出是它们的和(隐性要求是输入参数必须能够进行加法运算)lambda **kwargs: 1；输入是任意键值对参数，输出是1 四个用法由于lambda语法是固定的，其本质上只有一种用法，那就是定义一个lambda函数。在实际中，根据这个lambda函数应用场景的不同，可以将lambda函数的用法扩展为以下几种： 将lambda函数赋值给一个变量，通过这个变量间接调用该lambda函数。例如，执行语句add=lambda x, y: x+y，定义了加法函数lambda x, y: x+y，并将其赋值给变量add，这样变量add便成为具有加法功能的函数。例如，执行add(1,2)，输出为3。 将lambda函数赋值给其他函数，从而将其他函数用该lambda函数替换。例如，为了把标准库time中的函数sleep的功能屏蔽(Mock)，我们可以在程序初始化时调用：time.sleep=lambda x:None。这样，在后续代码中调用time库的sleep函数将不会执行原有的功能。例如，执行time.sleep(3)时，程序不会休眠3秒钟，而是什么都不做。 将lambda函数作为其他函数的返回值，返回给调用者。函数的返回值也可以是函数。例如return lambda x, y: x+y返回一个加法函数。这时，lambda函数实际上是定义在某个函数内部的函数，称之为嵌套函数，或者内部函数。对应的，将包含嵌套函数的函数称之为外部函数。内部函数能够访问外部函数的局部变量，这个特性是闭包(Closure)编程的基础，在这里我们不展开。 将lambda函数作为参数传递给其他函数。 部分Python内置函数接收函数作为参数。典型的此类内置函数有这些。filter函数。此时lambda函数用于指定过滤列表元素的条件。例如filter(lambda x: x % 3 == 0, [1, 2, 3])指定将列表[1,2,3]中能够被3整除的元素过滤出来，其结果是[3]。 sorted函数。此时lambda函数用于指定对列表中所有元素进行排序的准则。例如sorted([1, 2, 3, 4, 5, 6, 7, 8, 9], key=lambda x: abs(5-x))将列表[1, 2, 3, 4, 5, 6, 7, 8, 9]按照元素与5距离从小到大进行排序，其结果是[5, 4, 6, 3, 7, 2, 8, 1, 9]。 map函数。此时lambda函数用于指定对列表中每一个元素的共同操作。例如map(lambda x: x+1, [1, 2,3])将列表[1, 2, 3]中的元素分别加1，其结果[2, 3, 4]。 reduce函数。此时lambda函数用于指定列表中两两相邻元素的结合条件。例如reduce(lambda a, b: &#39;{}, {}&#39;.format(a, b), [1, 2, 3, 4, 5, 6, 7, 8, 9])将列表 [1, 2, 3, 4, 5, 6, 7, 8, 9]中的元素从左往右两两以逗号分隔的字符的形式依次结合起来，其结果是’1, 2, 3, 4, 5, 6, 7, 8, 9’。 另外，部分Python库函数也接收函数作为参数，例如gevent的spawn函数。此时，lambda函数也能够作为参数传入。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>lambda表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性代数行列式总结]]></title>
    <url>%2F2018%2F11%2F28%2Fpost%2F</url>
    <content type="text"><![CDATA[最近入坑机器学习，线性代数的知识用到很多，所以就回顾了一下，发现也是挺有意思的。行列式对于方阵给出一个特殊的定义值，与方阵的秩和方阵对应的齐次线性方程有没有唯一非零解有着很大的关系。 定义当$n\geq2$时，$n\times n$矩阵$A=\begin{bmatrix}a_{ij}\end{bmatrix}$的行列式是形如$\pm a_{ij} detA_{ij}$的n个项的和，其中加减号交替出现，这里的$a_{11},a_{12},a_{13}…a_{1n}$来自于第一行，即 \begin{aligned} detA&=a_{11}\cdot detA_{11}-a_{12}\cdot detA_{12}+\cdots +(-1)^{1+n}a_{1n}detA_{1n}\\ &=\sum_{j=1}^{n}(-1)^{1+j}a_{1j}detA_{1j}\\ \end{aligned}当然这是针对第一行展开的，从中可以看出$n\times n$阶的行列式被展开成若干个$(n-1)\times(n-1)$阶的行列式。$detA_{1j}$称为代数余子式，是划掉行列式A的第$1$行第$j$列后余下行列式的值，也可以对第$i$行进行展开，$1$替换成$i$即可。同样地，也可以对某一列进行展开。 定理 若$A$为三角阵，则$detA$为主对角线上元素乘积。这里的三角阵仅考虑行列式主对角线上边或下边元素全为零的情况。 行变换性质。令$A$是一个方阵，则有 若$A$的一行加上另一行的倍数得到$B$，则$detA=detB$ 若$A$的两行互换得到$B$，则$detA=-detB$ 若$A$的某行乘以k得到$B$，则$detA=kdetB$ $A$中有任何一行为0，则$detA=0$ 实际上，列变换也具有这些性质通过行列式的行变换，可以将一个复杂的行列式化简成三角型，如果化成阶梯型后不是三角型，则说明行列式值为0。 当且仅当$detA\neq 0$时方阵$A$是可逆的 若$A$为一个$n\times n$矩阵，则$detA^T=detA$ 乘法性质。$det(AB)=(detA)(detB)$ 线性方程组的解集问题 齐次线性方程组的解集 首先说一下什么是齐次线性方程组。就是方程组可以写成$A\textbf x=\textbf 0$，$A$是系数矩阵($m\times n$阶)，$\textbf x$是未知数n维列向量。显然这个方程必然有零解($x_1=0,x_2=0\cdots x_n=0$)。 有没有非零解，取决于方程组有没有自由变量。如果系数矩阵的行秩$\geq$未知数个数n（事实上只能$=$，因为任何矩阵行秩$=$列秩$=$秩），也就是线性无关的有效方程的个数$=$未知数个数n，方程只有零解。如果小于，则$n-$行秩就是方程组自有变量的个数。如果$x_1,x_2$是自有变量的话，那么通解为$\textbf x=x_1\textbf u+x_2\textbf v$，$\textbf u,\textbf v$为由方程解出来的列向量。 非齐次线性方程的解集 非齐次线性方程组是为$A\textbf x=\textbf b$的形式，$\textbf b$为n维非$0$列向量。它的解有三种情况，由增广矩阵$\begin{bmatrix}A&amp;\textbf b\end{bmatrix}$与系数矩阵$A$的秩的关系决定。若$r_{系数矩阵}=r_{增广矩阵}=n$，则有唯一解；若$r_{系数矩阵}=r_{增广矩阵}&lt;n$,则有无穷解。若$r_{系数矩阵}\neq r_{增广矩阵}$，则无解。（其中n为未知数的个数）。$r_{系数矩阵}\neq r_{增广矩阵}$反映了给定的线性方程组有互相矛盾的情况，其差为矛盾线性方程的个数；若$r_{系数矩阵}=r_{增广矩阵}&lt;n$，则说明给定的线性无关方程的个数小于未知变量个数，自然会有无穷多个解。 如果非齐次线性方程组有解，且p是一个特解，则$A\textbf x=\textbf b$的解集所有形如$\textbf w=\textbf p+\textbf v_{h}$，其中$\textbf v_{h}$是齐次线性方程组$A\textbf x=\textbf 0$的通解。克拉默法则克拉默法则是用来求解系数矩阵为方阵且可逆的非齐次线性方程组的唯一解的定理。首先定义一个替换矩阵，对于任意$n\times n$矩阵$A$和任意$\mathbb{R^{n}}$中向量$\textbf b$，令${A_i(b)}$表示$A$中第i列由向量$b$替换得到的矩阵。即 {A_i(b)=}\begin{bmatrix} {a_1}& \cdots &{b} &\cdots &{a_n} \end{bmatrix}接下来正式说明一下什么是克拉默法则设$ A$是一个可逆的$n\times n$矩阵，对任意$\mathbb{R^{n}}$中向量$ b$，方程${Ax=b}$的唯一解可由下式给出， {x_i=\frac{detA_ib}{detA},i=1,2\cdots n}$detA\neq 0$再加上$n\times n$方阵的条件可以说明$r_{系数矩阵}=r_{增广矩阵}=n$]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
        <tag>行列式</tag>
      </tags>
  </entry>
</search>
