<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>追风少年</title>
  
  <subtitle>Code is poetry</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="hjx051013.github.io/"/>
  <updated>2018-11-29T14:47:53.299Z</updated>
  <id>hjx051013.github.io/</id>
  
  <author>
    <name>jiaxinhuang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python中的lambda表达式</title>
    <link href="hjx051013.github.io/2018/11/29/python-lambda/"/>
    <id>hjx051013.github.io/2018/11/29/python-lambda/</id>
    <published>2018-11-29T14:29:38.000Z</published>
    <updated>2018-11-29T14:47:53.299Z</updated>
    
    <content type="html"><![CDATA[<p>这里，我们通过阅读各方资料，总结了关于Python中的lambda的“一个语法，三个特性，四个用法”。</p><h3 id="一个语法"><a href="#一个语法" class="headerlink" title="一个语法"></a>一个语法</h3><p>在Python中，lambda的语法是唯一的。其形式如下：</p><blockquote><p>lambda argument_list: expression</p></blockquote><p>其中，lambda是Python预留的关键字，argument_list和expression由用户自定义。具体介绍如下。<br>这里的argument_list是参数列表。它的结构与Python中函数(function)的参数列表是一样的。具体来说，argument_list可以有非常多的形式。例如：</p><ul><li>a, b</li><li>a=1, b=2</li><li>*args</li><li>**kwargs</li><li>a, b=1, *args</li><li>空</li><li>……</li></ul><p>这里的expression是一个关于参数的表达式。表达式中出现的参数需要在argument_list中有定义，并且表达式只能是单行的。以下都是合法的表达式：</p><ul><li>1</li><li>None</li><li>a + b</li><li>sum(a)</li><li>1 if a &gt;10 else 0</li><li>……</li></ul><p>这里的<code>lambda argument_list: expression</code>表示的是一个函数。这个函数叫做lambda函数。</p><h3 id="三个特性"><a href="#三个特性" class="headerlink" title="三个特性"></a>三个特性</h3><p>lambda函数有如下特性：</p><ul><li>lambda函数是匿名的：所谓匿名函数，通俗地说就是没有名字的函数。lambda函数没有名字。</li><li>lambda函数有输入和输出：输入是传入到参数列表argument_list的值，输出是根据表达式expression计算得到的值。</li><li>lambda函数一般功能简单：单行expression决定了lambda函数不可能完成复杂的逻辑，只能完成非常简单的功能。由于其实现的功能一目了然，甚至不需要专门的名字来说明。</li></ul><p>下面是一些lambda函数示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lambda x, y: x*y；函数输入是x和y，输出是它们的积x*y</span><br><span class="line"></span><br><span class="line">lambda:None；函数没有输入参数，输出是None</span><br><span class="line"></span><br><span class="line">lambda *args: sum(args); 输入是任意个数的参数，输出是它们的和(隐性要求是输入参数必须能够进行加法运算)</span><br><span class="line"></span><br><span class="line">lambda **kwargs: 1；输入是任意键值对参数，输出是1</span><br></pre></td></tr></table></figure></p><h3 id="四个用法"><a href="#四个用法" class="headerlink" title="四个用法"></a>四个用法</h3><p>由于lambda语法是固定的，其本质上只有一种用法，那就是定义一个lambda函数。在实际中，根据这个lambda函数应用场景的不同，可以将lambda函数的用法扩展为以下几种：</p><ol><li>将lambda函数赋值给一个变量，通过这个变量间接调用该lambda函数。例如，执行语句<code>add=lambda x, y: x+y</code>，定义了加法函数<code>lambda x, y: x+y</code>，并将其赋值给变量add，这样变量add便成为具有加法功能的函数。例如，执行add(1,2)，输出为3。</li><li>将lambda函数赋值给其他函数，从而将其他函数用该lambda函数替换。例如，为了把标准库time中的函数sleep的功能屏蔽(Mock)，我们可以在程序初始化时调用：<code>time.sleep=lambda x:None</code>。这样，在后续代码中调用time库的sleep函数将不会执行原有的功能。例如，执行<code>time.sleep(3)</code>时，程序不会休眠3秒钟，而是什么都不做。</li><li>将lambda函数作为其他函数的返回值，返回给调用者。函数的返回值也可以是函数。例如<code>return lambda x, y: x+y</code>返回一个加法函数。这时，lambda函数实际上是定义在某个函数内部的函数，称之为嵌套函数，或者内部函数。对应的，将包含嵌套函数的函数称之为外部函数。内部函数能够访问外部函数的局部变量，这个特性是闭包(Closure)编程的基础，在这里我们不展开。</li><li>将lambda函数作为参数传递给其他函数。<ul><li>部分Python内置函数接收函数作为参数。典型的此类内置函数有这些。filter函数。此时lambda函数用于指定过滤列表元素的条件。例如<code>filter(lambda x: x % 3 == 0, [1, 2, 3])</code>指定将列表[1,2,3]中能够被3整除的元素过滤出来，其结果是[3]。</li><li>sorted函数。此时lambda函数用于指定对列表中所有元素进行排序的准则。例如<code>sorted([1, 2, 3, 4, 5, 6, 7, 8, 9], key=lambda x: abs(5-x))</code>将列表[1, 2, 3, 4, 5, 6, 7, 8, 9]按照元素与5距离从小到大进行排序，其结果是[5, 4, 6, 3, 7, 2, 8, 1, 9]。</li><li>map函数。此时lambda函数用于指定对列表中每一个元素的共同操作。例如<code>map(lambda x: x+1, [1, 2,3])</code>将列表[1, 2, 3]中的元素分别加1，其结果[2, 3, 4]。</li><li>reduce函数。此时lambda函数用于指定列表中两两相邻元素的结合条件。例如<code>reduce(lambda a, b: &#39;{}, {}&#39;.format(a, b), [1, 2, 3, 4, 5, 6, 7, 8, 9])</code>将列表 [1, 2, 3, 4, 5, 6, 7, 8, 9]中的元素从左往右两两以逗号分隔的字符的形式依次结合起来，其结果是’1, 2, 3, 4, 5, 6, 7, 8, 9’。</li><li>另外，部分Python库函数也接收函数作为参数，例如gevent的spawn函数。此时，lambda函数也能够作为参数传入。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里，我们通过阅读各方资料，总结了关于Python中的lambda的“一个语法，三个特性，四个用法”。&lt;/p&gt;
&lt;h3 id=&quot;一个语法&quot;&gt;&lt;a href=&quot;#一个语法&quot; class=&quot;headerlink&quot; title=&quot;一个语法&quot;&gt;&lt;/a&gt;一个语法&lt;/h3&gt;&lt;p&gt;在Py
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>线性代数行列式总结</title>
    <link href="hjx051013.github.io/2018/11/28/post/"/>
    <id>hjx051013.github.io/2018/11/28/post/</id>
    <published>2018-11-28T03:24:25.000Z</published>
    <updated>2018-11-28T06:04:21.597Z</updated>
    
    <content type="html"><![CDATA[<p>最近入坑机器学习，线性代数的知识用到很多，所以就回顾了一下，发现也是挺有意思的。<br>行列式对于方阵给出一个特殊的定义值，与方阵的秩和方阵对应的齐次线性方程有没有唯一非零解有着很大的关系。</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>当$n\geq2$时，$n\times n$矩阵$A=\begin{bmatrix}a_{ij}\end{bmatrix}$的行列式是形如$\pm a_{ij} detA_{ij}$的n个项的和，其中加减号交替出现，这里的$a_{11},a_{12},a_{13}…a_{1n}$来自于第一行，即</p><script type="math/tex; mode=display">\begin{aligned}detA&=a_{11}\cdot detA_{11}-a_{12}\cdot detA_{12}+\cdots +(-1)^{1+n}a_{1n}detA_{1n}\\&=\sum_{j=1}^{n}(-1)^{1+j}a_{1j}detA_{1j}\\\end{aligned}</script><p>当然这是针对第一行展开的，从中可以看出$n\times n$阶的行列式被展开成若干个$(n-1)\times(n-1)$阶的行列式。$detA_{1j}$称为代数余子式，是划掉行列式A的第$1$行第$j$列后余下行列式的值，也可以对第$i$行进行展开，$1$替换成$i$即可。同样地，也可以对某一列进行展开。</p><h4 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h4><ol><li>若$A$为三角阵，则$detA$为主对角线上元素乘积。这里的三角阵仅考虑行列式主对角线上边或下边元素全为零的情况。</li><li><p>行变换性质。令$A$是一个方阵，则有</p><ul><li>若$A$的一行加上另一行的倍数得到$B$，则$detA=detB$ </li><li>若$A$的两行互换得到$B$，则$detA=-detB$</li><li>若$A$的某行乘以k得到$B$，则$detA=kdetB$</li><li>$A$中有任何一行为0，则$detA=0$</li></ul><p>实际上，列变换也具有这些性质<br>通过行列式的行变换，可以将一个复杂的行列式化简成三角型，如果化成阶梯型后不是三角型，则说明行列式值为0。</p><ol><li>当且仅当$detA\neq 0$时方阵$A$是可逆的</li><li>若$A$为一个$n\times n$矩阵，则$detA^T=detA$</li><li>乘法性质。$det(AB)=(detA)(detB)$</li></ol></li></ol><h4 id="线性方程组的解集问题"><a href="#线性方程组的解集问题" class="headerlink" title="线性方程组的解集问题"></a>线性方程组的解集问题</h4><ul><li>齐次线性方程组的解集<ul><li>首先说一下什么是齐次线性方程组。就是方程组可以写成$A\textbf x=\textbf 0$，$A$是系数矩阵($m\times n$阶)，$\textbf x$是未知数n维列向量。显然这个方程必然有零解($x_1=0,x_2=0\cdots x_n=0$)。</li><li>有没有非零解，取决于方程组有没有自由变量。如果系数矩阵的行秩$\geq$未知数个数n（事实上只能$=$，因为任何矩阵行秩$=$列秩$=$秩），也就是线性无关的有效方程的个数$=$未知数个数n，方程只有零解。如果小于，则$n-$行秩就是方程组自有变量的个数。如果$x_1,x_2$是自有变量的话，那么通解为$\textbf x=x_1\textbf u+x_2\textbf v$，$\textbf u,\textbf v$为由方程解出来的列向量。</li></ul></li><li>非齐次线性方程的解集<ul><li>非齐次线性方程组是为$A\textbf x=\textbf b$的形式，$\textbf b$为n维非$0$列向量。它的解有三种情况，由增广矩阵<br>$\begin{bmatrix}A&amp;\textbf b\end{bmatrix}$与系数矩阵$A$的秩的关系决定。若$r_{系数矩阵}=r_{增广矩阵}=n$，则有唯一解；若$r_{系数矩阵}=r_{增广矩阵}&lt;n$,则有无穷解。若$r_{系数矩阵}\neq r_{增广矩阵}$，则无解。（其中n为未知数的个数）。$r_{系数矩阵}\neq r_{增广矩阵}$反映了给定的线性方程组有互相矛盾的情况，其差为矛盾线性方程的个数；若$r_{系数矩阵}=r_{增广矩阵}&lt;n$，则说明给定的线性无关方程的个数小于未知变量个数，自然会有无穷多个解。<ul><li>如果非齐次线性方程组有解，且p是一个特解，则$A\textbf x=\textbf b$的解集所有形如$\textbf w=\textbf p+\textbf v_{h}$，其中$\textbf v_{h}$是齐次线性方程组$A\textbf x=\textbf 0$的通解。<h4 id="克拉默法则"><a href="#克拉默法则" class="headerlink" title="克拉默法则"></a>克拉默法则</h4>克拉默法则是用来求解系数矩阵为方阵且可逆的非齐次线性方程组的唯一解的定理。首先定义一个替换矩阵，对于任意$n\times n$矩阵$A$和任意$\mathbb{R^{n}}$中向量$\textbf b$，令${A_i(b)}$表示$A$中第i列由向量$b$替换得到的矩阵。即</li></ul></li></ul></li></ul><script type="math/tex; mode=display">{A_i(b)=}\begin{bmatrix} {a_1}& \cdots &{b}  &\cdots  &{a_n} \end{bmatrix}</script><p>接下来正式说明一下什么是克拉默法则<br>设$ A$是一个可逆的$n\times n$矩阵，对任意$\mathbb{R^{n}}$中向量$ b$，方程${Ax=b}$的唯一解可由下式给出，</p><script type="math/tex; mode=display">{x_i=\frac{detA_ib}{detA},i=1,2\cdots n}</script><p>$detA\neq 0$再加上$n\times n$方阵的条件可以说明$r_{系数矩阵}=r_{增广矩阵}=n$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近入坑机器学习，线性代数的知识用到很多，所以就回顾了一下，发现也是挺有意思的。&lt;br&gt;行列式对于方阵给出一个特殊的定义值，与方阵的秩和方阵对应的齐次线性方程有没有唯一非零解有着很大的关系。&lt;/p&gt;
&lt;h4 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="线性代数" scheme="hjx051013.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
</feed>
